{"version":3,"sources":["../src/action.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { JSONSchema7 } from 'json-schema';\nimport type * as z from 'zod';\nimport { getAsyncContext } from './async-context.js';\nimport { lazy } from './async.js';\nimport { getContext, runWithContext, type ActionContext } from './context.js';\nimport type { ActionType, Registry } from './registry.js';\nimport { parseSchema } from './schema.js';\nimport {\n  SPAN_TYPE_ATTR,\n  runInNewSpan,\n  setCustomMetadataAttributes,\n} from './tracing.js';\n\nexport { StatusCodes, StatusSchema, type Status } from './statusTypes.js';\nexport type { JSONSchema7 };\n\nconst makeNoopAbortSignal = () => new AbortController().signal;\n\n/**\n * Action metadata.\n */\nexport interface ActionMetadata<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  actionType?: ActionType;\n  name: string;\n  description?: string;\n  inputSchema?: I;\n  inputJsonSchema?: JSONSchema7;\n  outputSchema?: O;\n  outputJsonSchema?: JSONSchema7;\n  streamSchema?: S;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Results of an action run. Includes telemetry.\n */\nexport interface ActionResult<O> {\n  result: O;\n  telemetry: {\n    traceId: string;\n    spanId: string;\n  };\n}\n\n/**\n * Options (side channel) data to pass to the model.\n */\nexport interface ActionRunOptions<S> {\n  /**\n   * Streaming callback (optional).\n   */\n  onChunk?: StreamingCallback<S>;\n\n  /**\n   * Additional runtime context data (ex. auth context data).\n   */\n  context?: ActionContext;\n\n  /**\n   * Additional span attributes to apply to OT spans.\n   */\n  telemetryLabels?: Record<string, string>;\n\n  /**\n   * Abort signal for the action request.\n   */\n  abortSignal?: AbortSignal;\n}\n\n/**\n * Options (side channel) data to pass to the model.\n */\nexport interface ActionFnArg<S> {\n  /**\n   * Whether the caller of the action requested streaming.\n   */\n  streamingRequested: boolean;\n\n  /**\n   * Streaming callback (optional).\n   */\n  sendChunk: StreamingCallback<S>;\n\n  /**\n   * Additional runtime context data (ex. auth context data).\n   */\n  context?: ActionContext;\n\n  /**\n   * Trace context containing trace and span IDs.\n   */\n  trace: {\n    traceId: string;\n    spanId: string;\n  };\n\n  /**\n   * Abort signal for the action request.\n   */\n  abortSignal: AbortSignal;\n\n  registry?: Registry;\n}\n\n/**\n * Streaming response from an action.\n */\nexport interface StreamingResponse<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** Iterator over the streaming chunks. */\n  stream: AsyncGenerator<z.infer<S>>;\n  /** Final output of the action. */\n  output: Promise<z.infer<O>>;\n}\n\n/**\n * Self-describing, validating, observable, locally and remotely callable function.\n */\nexport type Action<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n  RunOptions extends ActionRunOptions<S> = ActionRunOptions<S>,\n> = ((input?: z.infer<I>, options?: RunOptions) => Promise<z.infer<O>>) & {\n  __action: ActionMetadata<I, O, S>;\n  __registry?: Registry;\n  run(\n    input?: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>>;\n\n  stream(\n    input?: z.infer<I>,\n    opts?: ActionRunOptions<z.infer<S>>\n  ): StreamingResponse<O, S>;\n};\n\n/**\n * Action factory params.\n */\nexport type ActionParams<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = {\n  name:\n    | string\n    | {\n        pluginId: string;\n        actionId: string;\n      };\n  description?: string;\n  inputSchema?: I;\n  inputJsonSchema?: JSONSchema7;\n  outputSchema?: O;\n  outputJsonSchema?: JSONSchema7;\n  metadata?: Record<string, any>;\n  use?: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[];\n  streamSchema?: S;\n  actionType: ActionType;\n};\n\nexport type ActionAsyncParams<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = ActionParams<I, O, S> & {\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>;\n};\n\nexport type SimpleMiddleware<I = any, O = any> = (\n  req: I,\n  next: (req?: I) => Promise<O>\n) => Promise<O>;\n\nexport type MiddlewareWithOptions<I = any, O = any, S = any> = (\n  req: I,\n  options: ActionRunOptions<S> | undefined,\n  next: (req?: I, options?: ActionRunOptions<S>) => Promise<O>\n) => Promise<O>;\n\n/**\n * Middleware function for actions.\n */\nexport type Middleware<I = any, O = any, S = any> =\n  | SimpleMiddleware<I, O>\n  | MiddlewareWithOptions<I, O, S>;\n\n/**\n * Creates an action with provided middleware.\n */\nexport function actionWithMiddleware<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  action: Action<I, O, S>,\n  middleware: Middleware<z.infer<I>, z.infer<O>, z.infer<S>>[]\n): Action<I, O, S> {\n  const wrapped = (async (\n    req: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ) => {\n    return (await wrapped.run(req, options)).result;\n  }) as Action<I, O, S>;\n  wrapped.__action = action.__action;\n  wrapped.run = async (\n    req: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>> => {\n    let telemetry;\n    const dispatch = async (\n      index: number,\n      req: z.infer<I>,\n      opts?: ActionRunOptions<z.infer<S>>\n    ) => {\n      if (index === middleware.length) {\n        // end of the chain, call the original model action\n        const result = await action.run(req, opts);\n        telemetry = result.telemetry;\n        return result.result;\n      }\n\n      const currentMiddleware = middleware[index];\n      if (currentMiddleware.length === 3) {\n        return (currentMiddleware as MiddlewareWithOptions<I, O, z.infer<S>>)(\n          req,\n          opts,\n          async (modifiedReq, modifiedOptions) =>\n            dispatch(index + 1, modifiedReq || req, modifiedOptions || opts)\n        );\n      } else if (currentMiddleware.length === 2) {\n        return (currentMiddleware as SimpleMiddleware<I, O>)(\n          req,\n          async (modifiedReq) => dispatch(index + 1, modifiedReq || req, opts)\n        );\n      } else {\n        throw new Error('unspported middleware function shape');\n      }\n    };\n    wrapped.stream = action.stream;\n\n    return { result: await dispatch(0, req, options), telemetry };\n  };\n  return wrapped;\n}\n\n/**\n * Creates an action with the provided config.\n */\nexport function action<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  config: ActionParams<I, O, S>,\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>\n): Action<I, O, z.infer<S>> {\n  const actionName =\n    typeof config.name === 'string'\n      ? config.name\n      : `${config.name.pluginId}/${config.name.actionId}`;\n  const actionMetadata = {\n    name: actionName,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    inputJsonSchema: config.inputJsonSchema,\n    outputSchema: config.outputSchema,\n    outputJsonSchema: config.outputJsonSchema,\n    streamSchema: config.streamSchema,\n    metadata: config.metadata,\n    actionType: config.actionType,\n  } as ActionMetadata<I, O, S>;\n\n  const actionFn = (async (\n    input?: I,\n    options?: ActionRunOptions<z.infer<S>>\n  ) => {\n    return (await actionFn.run(input, options)).result;\n  }) as Action<I, O, z.infer<S>>;\n  actionFn.__action = { ...actionMetadata };\n\n  actionFn.run = async (\n    input: z.infer<I>,\n    options?: ActionRunOptions<z.infer<S>>\n  ): Promise<ActionResult<z.infer<O>>> => {\n    input = parseSchema(input, {\n      schema: config.inputSchema,\n      jsonSchema: config.inputJsonSchema,\n    });\n    let traceId;\n    let spanId;\n    let output = await runInNewSpan(\n      {\n        metadata: {\n          name: actionName,\n        },\n        labels: {\n          [SPAN_TYPE_ATTR]: 'action',\n          'genkit:metadata:subtype': config.actionType,\n          ...options?.telemetryLabels,\n        },\n      },\n      async (metadata, span) => {\n        setCustomMetadataAttributes({\n          subtype: config.actionType,\n        });\n        if (options?.context) {\n          setCustomMetadataAttributes({\n            context: JSON.stringify(options.context),\n          });\n        }\n\n        traceId = span.spanContext().traceId;\n        spanId = span.spanContext().spanId;\n        metadata.name = actionName;\n        metadata.input = input;\n\n        try {\n          const actFn = () =>\n            fn(input, {\n              ...options,\n              // Context can either be explicitly set, or inherited from the parent action.\n              context: {\n                ...actionFn.__registry?.context,\n                ...(options?.context ?? getContext()),\n              },\n              streamingRequested:\n                !!options?.onChunk &&\n                options.onChunk !== sentinelNoopStreamingCallback,\n              sendChunk: options?.onChunk ?? sentinelNoopStreamingCallback,\n              trace: {\n                traceId,\n                spanId,\n              },\n              registry: actionFn.__registry,\n              abortSignal: options?.abortSignal ?? makeNoopAbortSignal(),\n            });\n          // if context is explicitly passed in, we run action with the provided context,\n          // otherwise we let upstream context carry through.\n          const output = await runWithContext(options?.context, actFn);\n\n          metadata.output = JSON.stringify(output);\n          return output;\n        } catch (err) {\n          if (typeof err === 'object') {\n            (err as any).traceId = traceId;\n          }\n          throw err;\n        }\n      }\n    );\n    output = parseSchema(output, {\n      schema: config.outputSchema,\n      jsonSchema: config.outputJsonSchema,\n    });\n    return {\n      result: output,\n      telemetry: {\n        traceId,\n        spanId,\n      },\n    };\n  };\n\n  actionFn.stream = (\n    input?: z.infer<I>,\n    opts?: ActionRunOptions<z.infer<S>>\n  ): StreamingResponse<O, S> => {\n    let chunkStreamController: ReadableStreamController<z.infer<S>>;\n    const chunkStream = new ReadableStream<z.infer<S>>({\n      start(controller) {\n        chunkStreamController = controller;\n      },\n      pull() {},\n      cancel() {},\n    });\n\n    const invocationPromise = actionFn\n      .run(config.inputSchema ? config.inputSchema.parse(input) : input, {\n        onChunk: ((chunk: z.infer<S>) => {\n          chunkStreamController.enqueue(chunk);\n        }) as S extends z.ZodVoid ? undefined : StreamingCallback<z.infer<S>>,\n        context: {\n          ...actionFn.__registry?.context,\n          ...(opts?.context ?? getContext()),\n        },\n        abortSignal: opts?.abortSignal,\n        telemetryLabels: opts?.telemetryLabels,\n      })\n      .then((s) => s.result)\n      .finally(() => {\n        chunkStreamController.close();\n      });\n\n    return {\n      output: invocationPromise,\n      stream: (async function* () {\n        const reader = chunkStream.getReader();\n        while (true) {\n          const chunk = await reader.read();\n          if (chunk.value) {\n            yield chunk.value;\n          }\n          if (chunk.done) {\n            break;\n          }\n        }\n        return await invocationPromise;\n      })(),\n    };\n  };\n\n  if (config.use) {\n    return actionWithMiddleware(actionFn, config.use);\n  }\n  return actionFn;\n}\n\nexport function isAction(a: unknown): a is Action {\n  return typeof a === 'function' && '__action' in a;\n}\n\n/**\n * Defines an action with the given config and registers it in the registry.\n */\nexport function defineAction<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  config: ActionParams<I, O, S>,\n  fn: (\n    input: z.infer<I>,\n    options: ActionFnArg<z.infer<S>>\n  ) => Promise<z.infer<O>>\n): Action<I, O, S> {\n  if (isInRuntimeContext()) {\n    throw new Error(\n      'Cannot define new actions at runtime.\\n' +\n        'See: https://github.com/firebase/genkit/blob/main/docs/errors/no_new_actions_at_runtime.md'\n    );\n  }\n  const act = action(config, async (i: I, options): Promise<z.infer<O>> => {\n    await registry.initializeAllPlugins();\n    return await runInActionRuntimeContext(() => fn(i, options));\n  });\n  act.__action.actionType = config.actionType;\n  registry.registerAction(config.actionType, act);\n  return act;\n}\n\n/**\n * Defines an action with the given config promise and registers it in the registry.\n */\nexport function defineActionAsync<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  registry: Registry,\n  actionType: ActionType,\n  name:\n    | string\n    | {\n        pluginId: string;\n        actionId: string;\n      },\n  config: PromiseLike<ActionAsyncParams<I, O, S>>,\n  onInit?: (action: Action<I, O, S>) => void\n): PromiseLike<Action<I, O, S>> {\n  const actionName =\n    typeof name === 'string' ? name : `${name.pluginId}/${name.actionId}`;\n  const actionPromise = lazy(() =>\n    config.then((resolvedConfig) => {\n      const act = action(\n        resolvedConfig,\n        async (i: I, options): Promise<z.infer<O>> => {\n          await registry.initializeAllPlugins();\n          return await runInActionRuntimeContext(() =>\n            resolvedConfig.fn(i, options)\n          );\n        }\n      );\n      act.__action.actionType = actionType;\n      onInit?.(act);\n      return act;\n    })\n  );\n  registry.registerActionAsync(actionType, actionName, actionPromise);\n  return actionPromise;\n}\n\n// Streaming callback function.\nexport type StreamingCallback<T> = (chunk: T) => void;\n\nconst streamingAlsKey = 'core.action.streamingCallback';\nexport const sentinelNoopStreamingCallback = () => null;\n\n/**\n * Executes provided function with streaming callback in async local storage which can be retrieved\n * using {@link getStreamingCallback}.\n */\nexport function runWithStreamingCallback<S, O>(\n  streamingCallback: StreamingCallback<S> | undefined,\n  fn: () => O\n): O {\n  return getAsyncContext().run(\n    streamingAlsKey,\n    streamingCallback || sentinelNoopStreamingCallback,\n    fn\n  );\n}\n\n/**\n * Retrieves the {@link StreamingCallback} previously set by {@link runWithStreamingCallback}\n *\n * @hidden\n */\nexport function getStreamingCallback<S>(): StreamingCallback<S> | undefined {\n  const cb = getAsyncContext().getStore<StreamingCallback<S>>(streamingAlsKey);\n  if (cb === sentinelNoopStreamingCallback) {\n    return undefined;\n  }\n  return cb;\n}\n\nconst runtimeContextAslKey = 'core.action.runtimeContext';\n\n/**\n * Checks whether the caller is currently in the runtime context of an action.\n */\nexport function isInRuntimeContext() {\n  return getAsyncContext().getStore(runtimeContextAslKey) === 'runtime';\n}\n\n/**\n * Execute the provided function in the action runtime context.\n */\nexport function runInActionRuntimeContext<R>(fn: () => R) {\n  return getAsyncContext().run(runtimeContextAslKey, 'runtime', fn);\n}\n\n/**\n * Execute the provided function outside the action runtime context.\n */\nexport function runOutsideActionRuntimeContext<R>(fn: () => R) {\n  return getAsyncContext().run(runtimeContextAslKey, 'outside', fn);\n}\n"],"mappings":"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","names":["action","req","output"]}