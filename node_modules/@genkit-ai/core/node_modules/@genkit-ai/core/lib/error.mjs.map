{"version":3,"sources":["../src/error.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Registry } from './registry.js';\nimport { httpStatusCode, type StatusName } from './statusTypes.js';\n\nexport type { StatusName };\n\nexport interface HttpErrorWireFormat {\n  details?: unknown;\n  message: string;\n  status: StatusName;\n}\n\n/**\n * Base error class for Genkit errors.\n */\nexport class GenkitError extends Error {\n  source?: string;\n  status: StatusName;\n  detail?: any;\n  code: number;\n\n  // For easy printing, we wrap the error with information like the source\n  // and status, but that's redundant with JSON.\n  originalMessage: string;\n\n  constructor({\n    status,\n    message,\n    detail,\n    source,\n  }: {\n    status: StatusName;\n    message: string;\n    detail?: any;\n    source?: string;\n  }) {\n    super(`${source ? `${source}: ` : ''}${status}: ${message}`);\n    this.originalMessage = message;\n    this.code = httpStatusCode(status);\n    this.status = status;\n    this.detail = detail;\n    this.name = 'GenkitError';\n  }\n\n  /**\n   * Returns a JSON-serializable representation of this object.\n   */\n  public toJSON(): HttpErrorWireFormat {\n    return {\n      // This error type is used by 3P authors with the field \"detail\",\n      // but the actual Callable protocol value is \"details\"\n      ...(this.detail === undefined ? {} : { details: this.detail }),\n      status: this.status,\n      message: this.originalMessage,\n    };\n  }\n}\n\nexport class UnstableApiError extends GenkitError {\n  constructor(level: 'beta', message?: string) {\n    super({\n      status: 'FAILED_PRECONDITION',\n      message: `${message ? message + ' ' : ''}This API requires '${level}' stability level.\\n\\nTo use this feature, initialize Genkit using \\`import {genkit} from \"genkit/${level}\"\\`.`,\n    });\n    this.name = 'UnstableApiError';\n  }\n}\n\n/**\n * assertUnstable allows features to raise exceptions when using Genkit from *more* stable initialized instances.\n *\n * @param level The maximum stability channel allowed.\n * @param message An optional message describing which feature is not allowed.\n */\nexport function assertUnstable(\n  registry: Registry,\n  level: 'beta',\n  message?: string\n) {\n  if (level === 'beta' && registry.apiStability === 'stable') {\n    throw new UnstableApiError(level, message);\n  }\n}\n\n/**\n * Creates a new class of Error for issues to be returned to users.\n * Using this error allows a web framework handler (e.g. express, next) to know it\n * is safe to return the message in a request. Other kinds of errors will\n * result in a generic 500 message to avoid the possibility of internal\n * exceptions being leaked to attackers.\n * In JSON requests, code will be an HTTP code and error will be a response body.\n * In streaming requests, { code, message } will be passed as the error message.\n */\nexport class UserFacingError extends GenkitError {\n  constructor(status: StatusName, message: string, details?: any) {\n    super({ status, detail: details, message });\n    super.name = 'UserFacingError';\n  }\n}\n\nexport function getHttpStatus(e: any): number {\n  if (e instanceof GenkitError) {\n    return e.code;\n  }\n  return 500;\n}\n\nexport function getCallableJSON(e: any): HttpErrorWireFormat {\n  if (e instanceof GenkitError) {\n    return e.toJSON();\n  }\n  return {\n    message: 'Internal Error',\n    status: 'INTERNAL',\n  };\n}\n\n/**\n * Extracts error message from the given error object, or if input is not an error then just turn the error into a string.\n */\nexport function getErrorMessage(e: any): string {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  return `${e}`;\n}\n\n/**\n * Extracts stack trace from the given error object, or if input is not an error then returns undefined.\n */\nexport function getErrorStack(e: any): string | undefined {\n  if (e instanceof Error) {\n    return e.stack;\n  }\n  return undefined;\n}\n"],"mappings":"AAiBA,SAAS,sBAAuC;AAazC,MAAM,oBAAoB,MAAM;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA,EAIA;AAAA,EAEA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAKG;AACD,UAAM,GAAG,SAAS,GAAG,MAAM,OAAO,EAAE,GAAG,MAAM,KAAK,OAAO,EAAE;AAC3D,SAAK,kBAAkB;AACvB,SAAK,OAAO,eAAe,MAAM;AACjC,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,OAAO;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKO,SAA8B;AACnC,WAAO;AAAA;AAAA;AAAA,MAGL,GAAI,KAAK,WAAW,SAAY,CAAC,IAAI,EAAE,SAAS,KAAK,OAAO;AAAA,MAC5D,QAAQ,KAAK;AAAA,MACb,SAAS,KAAK;AAAA,IAChB;AAAA,EACF;AACF;AAEO,MAAM,yBAAyB,YAAY;AAAA,EAChD,YAAY,OAAe,SAAkB;AAC3C,UAAM;AAAA,MACJ,QAAQ;AAAA,MACR,SAAS,GAAG,UAAU,UAAU,MAAM,EAAE,sBAAsB,KAAK;AAAA;AAAA,8EAAqG,KAAK;AAAA,IAC/K,CAAC;AACD,SAAK,OAAO;AAAA,EACd;AACF;AAQO,SAAS,eACd,UACA,OACA,SACA;AACA,MAAI,UAAU,UAAU,SAAS,iBAAiB,UAAU;AAC1D,UAAM,IAAI,iBAAiB,OAAO,OAAO;AAAA,EAC3C;AACF;AAWO,MAAM,wBAAwB,YAAY;AAAA,EAC/C,YAAY,QAAoB,SAAiB,SAAe;AAC9D,UAAM,EAAE,QAAQ,QAAQ,SAAS,QAAQ,CAAC;AAC1C,UAAM,OAAO;AAAA,EACf;AACF;AAEO,SAAS,cAAc,GAAgB;AAC5C,MAAI,aAAa,aAAa;AAC5B,WAAO,EAAE;AAAA,EACX;AACA,SAAO;AACT;AAEO,SAAS,gBAAgB,GAA6B;AAC3D,MAAI,aAAa,aAAa;AAC5B,WAAO,EAAE,OAAO;AAAA,EAClB;AACA,SAAO;AAAA,IACL,SAAS;AAAA,IACT,QAAQ;AAAA,EACV;AACF;AAKO,SAAS,gBAAgB,GAAgB;AAC9C,MAAI,aAAa,OAAO;AACtB,WAAO,EAAE;AAAA,EACX;AACA,SAAO,GAAG,CAAC;AACb;AAKO,SAAS,cAAc,GAA4B;AACxD,MAAI,aAAa,OAAO;AACtB,WAAO,EAAE;AAAA,EACX;AACA,SAAO;AACT;","names":[]}